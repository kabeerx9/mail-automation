import { Request, Response } from 'express';
import { EmailService, CSVService, EmailResponse } from '../types';
import logger from '../utils/logger';
import prisma from '@/lib/prisma';
import nodemailer from 'nodemailer';
import { z } from 'zod';
import { ValidationError, NotFoundError } from '../types/errors';

const testEmailSchema = z.object({
    email: z.string().email('Invalid email format'),
    useAI: z.boolean().optional().default(false)
}).strict();

export class EmailController {
    constructor(
        private emailService: EmailService,
        private csvService: CSVService
    ) {}

    generateTransporter = (configuration: any) => {
        if (!configuration) {
            return null;
        }

        const modifiedTransporterConfiguration = {
            host: configuration.SMTP_HOST,
            port: parseInt(configuration.SMTP_PORT),
            auth: {
                user: configuration.SMTP_USER,
                pass: configuration.SMTP_PASS
            }
        };

        return nodemailer.createTransport(modifiedTransporterConfiguration);
    }

    getStatus = async (_req: Request, res: Response) => {
        const recruiters = await this.csvService.readRecruiters();
        res.json(recruiters);
    }

    sendTestEmail = async (req: Request, res: Response) => {
        const startTime = performance.now();
        const validatedData = testEmailSchema.parse(req.body);
        logger.info('Schema validation time:', { time: performance.now() - startTime });

        const prismaStartTime = performance.now();
        const configuration = await prisma.configuration.findUnique({
            where: {
                userId: req.user?.id as string
            }
        });
        logger.info('Prisma query time:', { time: performance.now() - prismaStartTime });

        if (!configuration) {
            throw new NotFoundError('Email configuration not found');
        }

        const testEmail = validatedData.email || configuration.EMAIL_FROM;
        const useAI = validatedData.useAI;

        const transporterStartTime = performance.now();
        const transporter = this.generateTransporter(configuration);
        logger.info('Transporter generation time:', { time: performance.now() - transporterStartTime });

        if (!transporter) {
            throw new ValidationError('Invalid email configuration');
        }

        if (!configuration.EMAIL_FROM || !configuration.EMAIL_SUBJECT ||
            !configuration.SMTP_HOST || !configuration.SMTP_PORT ||
            !configuration.SMTP_USER || !configuration.SMTP_PASS) {
            throw new ValidationError('Incomplete email configuration');
        }

        console.log('useAI', useAI);

        let emailBody: string;
        if (useAI) {
            try {
                console.log('Generating AI content');
                emailBody = 'This should have been generated by AI';
            } catch (error) {
                logger.error('Failed to generate AI content:', error);
                emailBody = 'This is a test email from the email automation system.';
            }
        } else {
            emailBody = 'This is a test email from the email automation system.';
        }

        const emailSendStartTime = performance.now();
        await this.emailService.sendEmail(
            testEmail,
            emailBody,
            transporter,
            configuration
        );
        logger.info('Email sending time:', { time: performance.now() - emailSendStartTime });

        const totalTime = performance.now() - startTime;
        logger.info('Total execution time:', { time: totalTime });

        res.json({
            success: true,
            message: `Test email sent successfully to ${testEmail}`,
            isAiGenerated: useAI,
            executionTimeMs: totalTime
        });
    }

    processEmails = async (req: Request, res: Response) => {
        const response: EmailResponse = {
            success: false,
            message: '',
            details: {
                sent: 0,
                failed: 0,
                errors: [],
            },
        };

        const configuration = await prisma.configuration.findUnique({
            where: {
                userId: req.user?.id as string
            }
        });

        if (!configuration) {
            throw new NotFoundError('Email configuration not found');
        }

        if (!configuration.EMAIL_FROM || !configuration.EMAIL_SUBJECT ||
            !configuration.SMTP_HOST || !configuration.SMTP_PORT ||
            !configuration.SMTP_USER || !configuration.SMTP_PASS) {
            throw new ValidationError('Incomplete email configuration');
        }

        const transporter = this.generateTransporter(configuration);

        if (!transporter) {
            throw new ValidationError('Invalid email configuration');
        }

        const recruiters = await this.csvService.readRecruiters();
        logger.info(`Processing ${recruiters.length} recruiters`);

        for (const recruiter of recruiters) {
            try {
                if (recruiter.ReachOutCount === 0) {
                    await this.emailService.sendEmail(
                        recruiter.Email,
                        this.generateEmailBody(recruiter.Name, recruiter.Company, recruiter.Role, configuration.EMAIL_FROM),
                        transporter,
                        configuration
                    );
                } else {
                    await this.emailService.sendEmail(
                        recruiter.Email,
                        this.generateFollowUpEmailBody(recruiter.Name, recruiter.Company, recruiter.Role, configuration.EMAIL_FROM),
                        transporter,
                        configuration
                    );
                }
                recruiter.Status = 'Sent';
                recruiter.ReachOutCount += 1;
                recruiter.LastContactDate = new Date().toISOString();
                response.details!.sent++;
            } catch (error) {
                recruiter.Status = 'Failed';
                response.details!.failed++;
                response.details!.errors.push({
                    email: recruiter.Email,
                    error: error instanceof Error ? error.message : 'Unknown error',
                });
            }
        }

        await this.csvService.updateRecruiters(recruiters);

        response.success = true;
        response.message = 'Email processing completed';
        res.json(response);
    }

    private generateEmailBody(name: string, company: string, role: string, from: string): string {
        return `Dear ${name},\n\nI hope this email finds you well. I noticed that ${company} is looking for a ${role}...`;
    }

    private generateFollowUpEmailBody(name: string, company: string, role: string, from: string): string {
        return `Dear ${name},\n\nI wanted to follow up on my previous email regarding the ${role} position at ${company}...`;
    }
}
